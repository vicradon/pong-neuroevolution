<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pong Neuroevolution</title>

    <meta
      name="description"
      content="Pong with Neuroevolution. You know, like the flappy one."
    />
    <meta property="og:title" content="Ultimate Pong Game" />
    <meta
      property="og:description"
      content="Pong with Neuroevolution. You know, like the flappy one."
    />
    <meta property="og:image" content="favicons/android-chrome-512x512.png" />
    <meta property="og:url" content="https://pong-neuroevolution.vercel.app" />

    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="favicons/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="favicons/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="favicons/favicon-16x16.png"
    />
    <link rel="manifest" href="favicons/site.webmanifest" />
    <link rel="shortcut icon" href="favicons/favicon.ico" />

    <style>
      .game-container {
        display: grid;
        justify-content: center;
      }

      .game-header {
        color: #333;
        text-align: center;
      }

      .game-controls {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: 1fr;
        align-items: center;
      }

      .score-display {
        display: flex;
        column-gap: 1rem;
        font-size: large;
        justify-content: center;
      }

      .rounds-display {
        justify-self: end;
      }

      .start-button {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      .game-canvas {
        border: 1px solid #333;
        border-radius: 5px;
      }
    </style>
  </head>

  <body>
    <div class="game-container">
      <h1 class="game-header">Pong</h1>

      <div class="game-controls">
        <div>
          <label for="gameModeSelector">Game Mode</label>
          <select name="gameModeSelector" id="gameModeSelector">
            <option value="LOGICAL_AI">Logical AI</option>
            <option value="ACTUAL_AI">Actual AI</option>
          </select>
        </div>
        <div class="score-display">
          <p id="player1Score">0</p>
          <p>:</p>
          <p id="player2Score">0</p>
        </div>

        <div class="rounds-display">
          Rounds: <span id="roundsCount">0</span>
        </div>
      </div>

      <button id="startButton" class="start-button">Press Play to Start</button>
      <canvas
        class="game-canvas"
        id="canvas"
        width="1200"
        height="700"
      ></canvas>
    </div>

    <script>
      // Constants
      const CANVAS_WIDTH = 1200;
      const CANVAS_HEIGHT = 700;
      const PADDLE_WIDTH = 20;
      const PADDLE_HEIGHT = 100;
      const PADDLE_SPEED = 5;
      const BALL_RADIUS = 10;
      const BALL_INITIAL_SPEED_X = 8;
      const BALL_MIN_SPEED_Y = 1;
      const BALL_MAX_SPEED_Y = 2;

      // DOM Elements
      const dom = {
        canvas: document.getElementById("canvas"),
        player1Score: document.getElementById("player1Score"),
        player2Score: document.getElementById("player2Score"),
        gameModeSelector: document.getElementById("gameModeSelector"),
        startButton: document.getElementById("startButton"),
        roundsCount: document.getElementById("roundsCount"),
      };

      // Game state
      const state = {
        gameMode: "LOGICAL_AI",
        gameRunning: false,
        rounds: 1,
        keys: {
          w: false,
          s: false,
          ArrowUp: false,
          ArrowDown: false,
        },
      };

      // Initial object positions
      const initialState = {
        ball: {
          x: CANVAS_WIDTH / 2,
          y: CANVAS_HEIGHT / 2,
          radius: BALL_RADIUS,
          dx: getRandomMultiplier() * BALL_INITIAL_SPEED_X,
          dy: getRandomNumber(BALL_MIN_SPEED_Y, BALL_MAX_SPEED_Y),
        },
        leftPaddle: {
          x: 20,
          y: CANVAS_HEIGHT / 2 - PADDLE_HEIGHT / 2,
        },
        rightPaddle: {
          x: CANVAS_WIDTH - 40,
          y: CANVAS_HEIGHT / 2 - PADDLE_HEIGHT / 2,
        },
      };

      // Game objects
      let ball = { ...initialState.ball };
      let leftPaddle = { ...initialState.leftPaddle };
      let rightPaddle = { ...initialState.rightPaddle };

      // Canvas context
      const ctx = dom.canvas.getContext("2d");

      // Utility functions
      function getRandomMultiplier() {
        return Math.random() > 0.5 ? -1 : 1;
      }

      function getRandomNumber(min, max) {
        return getRandomMultiplier() * (Math.random() * (max - min) + min);
      }

      // Game logic functions
      function checkCollision(paddle) {
        return (
          ball.x - ball.radius <= paddle.x + PADDLE_WIDTH &&
          ball.x + ball.radius >= paddle.x &&
          ball.y >= paddle.y &&
          ball.y <= paddle.y + PADDLE_HEIGHT
        );
      }

      function newRound() {
        leftPaddle = { ...initialState.leftPaddle };
        rightPaddle = { ...initialState.rightPaddle };

        if (state.rounds % 5 === 0 && state.rounds !== 0) {
          dom.startButton.style.display = "block";
          dom.gameModeSelector.disabled = false;
          dom.startButton.textContent = "Click to continue";
          ball = {
            ...initialState.ball,
            dx: 0,
            dy: 0,
          };
        } else {
          ball = {
            ...initialState.ball,
            dx: getRandomMultiplier() * BALL_INITIAL_SPEED_X,
            dy: getRandomNumber(BALL_MIN_SPEED_Y, BALL_MAX_SPEED_Y),
          };
          state.rounds += 1;
          dom.roundsCount.textContent = state.rounds;
        }
      }

      // Rendering
      function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw center line
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(CANVAS_WIDTH / 2, 0);
        ctx.lineTo(CANVAS_WIDTH / 2, CANVAS_HEIGHT);
        ctx.strokeStyle = "#999";
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw paddles
        ctx.fillStyle = "gray";
        ctx.fillRect(leftPaddle.x, leftPaddle.y, PADDLE_WIDTH, PADDLE_HEIGHT);

        ctx.fillStyle = "darkgray";
        ctx.fillRect(rightPaddle.x, rightPaddle.y, PADDLE_WIDTH, PADDLE_HEIGHT);

        // Draw ball
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = "tomato";
        ctx.fill();
        ctx.closePath();
      }

      // Game modes
      function runLogicalAIMode() {
        state.gameRunning = true;

        // Update ball position
        ball.x += ball.dx;
        ball.y += ball.dy;

        // Handle collisions
        if (checkCollision(leftPaddle) || checkCollision(rightPaddle)) {
          ball.dx *= -1;
        }

        // Handle scoring
        if (
          ball.x > CANVAS_WIDTH - (PADDLE_WIDTH + 20) &&
          !checkCollision(rightPaddle)
        ) {
          dom.player1Score.textContent =
            Number(dom.player1Score.textContent) + 1;
          newRound();
        }

        if (ball.x < PADDLE_WIDTH + 20 && !checkCollision(leftPaddle)) {
          dom.player2Score.textContent =
            Number(dom.player2Score.textContent) + 1;
          newRound();
        }

        // Handle wall bounces
        if (ball.y > CANVAS_HEIGHT - 5 || ball.y < 5) {
          ball.dy *= -1;
        }

        // Handle player paddle movement
        if ((state.keys.ArrowUp || state.keys.w) && leftPaddle.y > 0) {
          leftPaddle.y -= PADDLE_SPEED;
        }

        if (
          (state.keys.ArrowDown || state.keys.s) &&
          leftPaddle.y < CANVAS_HEIGHT - PADDLE_HEIGHT
        ) {
          leftPaddle.y += PADDLE_SPEED;
        }

        // Handle AI paddle movement
        if (ball.dx > 0 && ball.x > CANVAS_WIDTH / 4) {
          if (
            ball.y > rightPaddle.y + PADDLE_HEIGHT / 2 &&
            rightPaddle.y < CANVAS_HEIGHT - PADDLE_HEIGHT
          ) {
            rightPaddle.y += PADDLE_SPEED;
          }

          if (ball.y < rightPaddle.y + PADDLE_HEIGHT / 2 && rightPaddle.y > 0) {
            rightPaddle.y -= PADDLE_SPEED;
          }
        }

        // Render the game
        draw();

        // Continue game loop if ball is moving
        if (ball.dx !== 0 || ball.dy !== 0) {
          requestAnimationFrame(update);
        } else {
          state.gameRunning = false;
        }
      }

      function runActualAIMode() {
        // Future implementation
      }

      // Main game loop
      function update() {
        if (state.gameMode === "LOGICAL_AI") {
          runLogicalAIMode();
        } else {
          runActualAIMode();
        }
      }

      // Event listeners
      dom.gameModeSelector.onchange = function () {
        state.gameMode = this.value;
      };

      dom.startButton.onclick = function () {
        if (state.gameMode === "ACTUAL_AI") {
          // Future implementation
        } else {
          this.style.display = "none";
          dom.roundsCount.textContent = state.rounds;

          // Restart ball if paused
          if (ball.dx === 0 && ball.dy === 0) {
            ball = {
              ...initialState.ball,
              dx: getRandomMultiplier() * BALL_INITIAL_SPEED_X,
              dy: getRandomNumber(BALL_MIN_SPEED_Y, BALL_MAX_SPEED_Y),
            };

            // Increment rounds if continuing after a 5-round pause
            if (state.rounds % 5 === 0) {
              state.rounds += 1;
              dom.roundsCount.textContent = state.rounds;
            }
          }

          if (!state.gameRunning) {
            state.gameRunning = true;
            update();
          }
        }
        dom.gameModeSelector.disabled = "disabled";
      };

      document.addEventListener("keydown", (e) => {
        if (e.key in state.keys) state.keys[e.key] = true;
      });

      document.addEventListener("keyup", (e) => {
        if (e.key in state.keys) state.keys[e.key] = false;
      });

      // Initial rendering
      draw();
    </script>
  </body>
</html>
